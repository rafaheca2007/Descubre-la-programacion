
final int tamX= 30; // Tamaño en X del ladrillo
final int tamY= 16; // Tamaño en Y del ladrillo
final int maxX= 10; // Número de ladrillos en X
final int maxY= 14; // Número de ladrillos en Y
final int priY= 40; // Eje Y de la primera fila de ladrillos
final double tambola= 14; // Tamaño de la bola
final double tamnave= 64; // Anchura de la nave

//--------------------
// Variables del juego
//--------------------
int nfase= 1;     // Número de fase actual
int nvidas= 6;    // Número de vidas
int npuntos= 0;   // Número de puntos
double vxpelota;  // Velocidad en X de la pelota
double vypelota;  // Velocidad en Y de la pelota
double pxpelota;  // Posición en X de la pelota
double pypelota;  // Posición en Y de la pelota
double pxnave;    // Posición en X de la nave
double pynave;    // Posición en Y de la nave
int cuentalad;    // Número de ladrillos que quedan por destruir
int pasos;        // Tiempo en la vida actual

int[][] ladrillos; // Estado actual del tablero


//----------------------------------
// Definición de las fases del juego
// Puedes crear tus propias fases,
// añadiendo un array de 14 cadenas
// de longitud 10, con los valores
// (R)ojo, (V)erde, (A)zul, (C)ian,
// (M)agente, amar(I)llo, (1,2...8) gris,
// (0) indestructible.
//----------------------------------
String[][] fases= {
 { // Fase 1
  "          ",
  "          ",
  "3333333333",
  "RRRRRRRRRR",
  "IIIIIIIIII",
  "AAAAAAAAAA",
  "MMMMMMMMMM",
  "VVVVVVVVVV",
  "          ",
  "          ",
  "          ",
  "          ",
  "          ",
  "          "},
 { // Fase 2
  "          ",
  "          ",
  " RR AA MM ",
  " RR AA MM ",
  "          ",
  "  CC  VV  ",
  "  CC  VV  ",
  "          ",
  " II RR AA ",
  " II RR AA ",
  " 22 22 22 ",
  "          ",
  "          ",
  "          "},
 { // Fase 3
  "0000000000",
  "          ",
  "RRRRRRRRRR",
  "          ",
  "00000000  ",
  "          ",
  "MMMMMMMMMM",
  "          ",
  "  00000000",
  "          ",
  "IIIIIIIIII",
  "          ",
  "00000000  ",
  "          "},
 { // Fase 4
  "    V   V ",
  "   VV  VV ",
  "   VV VV  ",
  "     V    ",
  "    V     ",
  "   RRRR   ",
  "  RRRRRR  ",
  " RRRRRRRR ",
  " RRRRRRRR ",
  " RRRRRRRR ",
  "  RRRRRR  ",
  "   RRRR   ",
  "          ",
  "          "},
 { // Fase 5
  "          ",
  "          ",
  "A R V M I ",
  "0 0 0 0 0 ",
  " V M I A R",
  " 0 0 0 0 0",
  "M I A R V ",
  "0 0 0 0 0 ",
  " I A R V M",
  " 0 0 0 0 0",
  "A R V M I ",
  "0 0 0 0 0 ",
  "          ",
  "          "},
 { // Fase 6
  "R         ",
  "VV        ",
  "III       ",
  "CCCC      ",
  "MMMMM     ",
  "AAAAAA    ",
  "RRRRRRR   ",
  "VVVVVVVV  ",
  "IIIIIIIII ",
  "3333333333",
  "          ",
  "          ",
  "          ",
  "          "},
 { // Fase 7
  "          ",
  "0000000000",
  "    0A    ",
  "   C0    I",
  " 0  0  0  ",
  " 0  0 R0  ",
  " 0 I0  0A ",
  " 0  0  0  ",
  " 0M    0 R",
  " 0    V0  ",
  " 000000000",
  "          ",
  "          ",
  "          "},

  { // Fase 8
  "          ",
  "          ",
  "CCCCCCCCCC",
  "C000RR000C",
  "C0RRRRRR0C",
  "C0R    R0C",
  "C0R    R0C",
  " C0R  R0C ",
  "  C0RR0C  ",
  "   CCCC   ",
  "          ",
  "          ",
  "          ",
  "          "},

 { // Fase 9
  "          ",
  "RR    RR  ",
  "RRR  RRRR ",
  "IIRRRRIIRR",
  "IIIRRIIIIR",
  "IIIIIIIIII",
  "IIIIIIIIII",
  "RRIIIIRRII",
  "RRRIIRRRRI",
  "  RRRR  RR",
  "   RR    R",
  "          ",
  "          ",
  "          "},
 { // Fase 10
  "          ",
  "       0C0",
  " 0A0   000",
  " 000      ",
  "          ",
  "          ",
  "    0R0   ",
  "    000   ",
  "          ",
  "          ",
  "0M0       ",
  "000   0V0 ",
  "      000 ",
  "          "},
 { // Fase 11
  "          ",
  "          ",
  "RMCAIVR   ",
  "VRMCAIVR0 ",
  "IVRMCAIV0 ",
  "AIVRMCAI0 ",
  "CAIVRMCA0 ",
  "MCAIVRMC0 ",
  "RMCAIVRM0 ",
  "VRMCAIVR0 ",
  "IVRMCAIV0 ",
  "AIVRMCAI0 ",
  "000000000 ",
  "          "},
 { // Fase 12
  "5678888765",
  "4434776445",
  "6544674345",
  "3223585422",
  "6655775445",
  "8877776777",
  "8887776777",
  "7876675577",
  "6766544666",
  "6667766655",
  "6654444455",
  "5665554565",
  "5666545665",
  "          "}
};

// Variables de choque de la pelota
double pxchoque;   // Posición de choque en X
double pychoque;   // Posición de choque en Y
double distchoque; // Distancia de bola a ladrillo
int xladrillo;     // Número de ladrillo en X
int yladrillo;     // Número de ladrillo en Y
final double sombra= 5;  // Desplazamiento de la sombra

//--------------------
// Funciones del juego
//--------------------

// Inicializar el tablero con un número de fase dado
void inicializa (int fase)
{
  fase= fase-1;
  // Inicializar los ladrillos según la fase
  ladrillos= new int [maxY][maxX];
  for (int y= 0; y<maxY; y++)
    for (int x= 0; x<maxX; x++)
       switch (fases[fase][y].charAt(x)) {
         case 'R': ladrillos[y][x]= 1; break;
         case 'V': ladrillos[y][x]= 2; break;
         case 'A': ladrillos[y][x]= 3; break;
         case 'C': ladrillos[y][x]= 4; break;
         case 'M': ladrillos[y][x]= 5; break;
         case 'I': ladrillos[y][x]= 6; break;
         case '1': ladrillos[y][x]= 7; break;
         case '2': ladrillos[y][x]= 8; break;
         case '3': ladrillos[y][x]= 9; break;
         case '4': ladrillos[y][x]= 10; break;
         case '5': ladrillos[y][x]= 11; break;
         case '6': ladrillos[y][x]= 12; break;
         case '7': ladrillos[y][x]= 13; break;
         case '8': ladrillos[y][x]= 14; break;
         case '0': ladrillos[y][x]= 200; break;
         default: ladrillos[y][x]= 0;
       }
  // Inicializar velocidades y posiciones
  vxpelota= 0;
  vypelota= 0;
  pxpelota= 160;
  pypelota= 280;
  pxnave= 160;
  pynave= 300;
  pasos= 0;
}

// Pintar un ladrillo dado
void pintaladrillo(int y, int x)
{
  noStroke();
  // Sombra del ladrillo
  fill(0,0,0,0.40);
  rect(x*tamX+1+10+sombra, priY+y*tamY+sombra, tamX, tamY);
  // Relleno del ladrillo según su color
  if (ladrillos[y][x]==1)
     fill(255,0,0);
  else if (ladrillos[y][x]==2)
     fill(0,255,0);
  else if (ladrillos[y][x]==3)
     fill(0,0,255);
  else if (ladrillos[y][x]==4)
     fill(0,255,255);
  else if (ladrillos[y][x]==5)
     fill(255,0,255);
  else if (ladrillos[y][x]==6)
     fill(255,255,0);
  else if (ladrillos[y][x]==200)
     fill(185,122,87);
  else
     fill(15*ladrillos[y][x],15*ladrillos[y][x],15*ladrillos[y][x]);
  rect(x*tamX+1+10, priY+y*tamY, tamX-1, tamY-1);
  // Líneas del ladrillo
  strokeWeight(2);
  stroke(255,255,255,0.6);
  line(x*tamX+2+10, priY+y*tamY+1, x*tamX+tamX+10, priY+y*tamY+1);
  line(x*tamX+tamX-1+10, priY+y*tamY, x*tamX+tamX-1+10, priY+y*tamY+tamY-2);
  if (ladrillos[y][x]==200) {
     line(x*tamX+13+10, priY+y*tamY+5, x*tamX+5+10, priY+y*tamY+13);
     line(x*tamX+22+10, priY+y*tamY+11, x*tamX+29+10, priY+y*tamY+4); 
  }
  stroke(0,0,0,0.4);
  line(x*tamX+1+10, priY+y*tamY+14, x*tamX+tamX-1+10, priY+y*tamY+tamY-2);
  line(x*tamX+2+10, priY+y*tamY+1, x*tamX+2+10, priY+y*tamY+tamY-1);
  if (ladrillos[y][x]==200) {
     line(x*tamX+13+10, priY+y*tamY+12, x*tamX+21+10, priY+y*tamY+4);
  }
}

// Pintar todos los ladrillos y el resto del tablero
void pintaladrillos()
{
  // Pintar el fondo
  if (nfase%3==1)
     image("https://mooshak.inf.um.es/~ginesgm/images/fondo1a.jpg", 0, 0, 320, 320);
  else if (nfase%3==2)
     image("https://mooshak.inf.um.es/~ginesgm/images/fondo2a.jpg", 0, 0, 320, 320);
  else
     image("https://mooshak.inf.um.es/~ginesgm/images/fondo3a.jpg", 0, 0, 320, 320);    
  cuentalad= 0;
  // Pintar los ladrillos
  for (int y= 0; y<maxY; y++)
    for (int x= 0; x<maxX; x++)
      if (ladrillos[y][x]!=0) {
        pintaladrillo(y,x);
        if (ladrillos[y][x]!=200)
          cuentalad++;
      }
  // Pintar el texto
  textSize(14);
  fill(255,255,255);
  text("Fase:", 10, 24);
  text(nfase, 62, 24);
  text("Vidas:", 90, 24);
  text(nvidas, 150, 24);
  text("Puntos:", 190, 24);
  text(npuntos, 260, 24);
  // Bola parada: pintar letras grandes en medio
  if (vxpelota==0.0 && vypelota==0.0 && nvidas>0) {
    textSize(48);
    fill(0,0,0,0.8);
    text("Fase", 60,150);
    text(nfase, 220,150);
    fill(255,255,255,0.8);
    text("Fase", 55,145);
    text(nfase, 215,145);
  }
}

// Pintar la bola
void pintabola()
{
  noStroke();
  fill(0,0,0,0.40);
  ellipse(pxpelota+sombra, pypelota+sombra, tambola, tambola);
  fill(255,60,60,1);
  ellipse(pxpelota, pypelota, tambola, tambola);
  fill(255,200,200);
  ellipse(pxpelota-3, pypelota-3, tambola/4, tambola/4);
}

// Pintar la nave
void pintanave()
{
  fill(0,0,0,0.40);
  ellipse(pxnave+sombra, pynave+sombra, tamnave, 14);
  stroke(20,20,20);
  strokeWeight(2);
  fill(100,100,100);
  ellipse(pxnave, pynave, tamnave, 14);
  fill(210,0,0);
  ellipse(pxnave-tamnave/2+8, pynave+2, 12, 12);
  ellipse(pxnave+tamnave/2-8, pynave+2, 12, 12);
  stroke(250,255,255,0.4);
  line(pxnave-tamnave/2+8, pynave-1, pxnave, pynave-3);
  line(pxnave, pynave-3, pxnave+tamnave/2-8, pynave-1);
}

// Pintar un mensaje de GAME OVER
void pintagameover()
{
  textSize(48);
  fill(0,0,0,0.8);
  text("GAME", 70,120);
  text("OVER", 70,200);
  fill(150+floor(random(100)),150+floor(random(100)),150+floor(random(100)),0.8);
  text("GAME", 65,115);
  text("OVER", 65,195);
}

// Calcular la distancia euclídea entre los puntos
// (x1,y1) y (x2,y2)
double distancia (double x1, double y1, double x2, double y2)
{
  double dx= x1-x2;
  double dy= y1-y2;
  return sqrt(dx*dx+dy*dy);
}

// Comprobar si valor está en el intervalo (min,max)
double enRango (double min, double valor, double max)
{
  if (valor<min) return min;
  else if (valor>max) return max;
  else return valor;
}

// Comprobar si la bola choca con el ladrillo dado
void compruebaladrillo(int y, int x)
{
  // No hay ladrillo en (y,x)
  if (y<0 || x<0 || y>=maxY || x>=maxX)
    return;
  if (ladrillos[y][x]==0)
    return;
  // Los 8 posibles puntos de choque: en las 4 esquinas del
  // ladrillo o en alguno de los 4 lados del mismo
  double[][] puntos= {
    {x*tamX+10, y*tamY+priY},
    {(x+1)*tamX+10, y*tamY+priY},
    {x*tamX+10, (y+1)*tamY+priY},
    {(x+1)*tamX+10, (y+1)*tamY+priY},
    {enRango(x*tamX+10,pxpelota,(x+1)*tamX+10), y*tamY+priY},
    {enRango(x*tamX+10,pxpelota,(x+1)*tamX+10), (y+1)*tamY+priY},
    {x*tamX+10, enRango(y*tamY+priY,pypelota,(y+1)*tamY+priY)},
    {(x+1)*tamX+10, enRango(y*tamY+priY,pypelota,(y+1)*tamY+priY)}    
  };
  // Comprobar los 8 puntos de choque, según su distancia
  // a la bola
  for (int i= 0; i<8; i++) {
    double dist= distancia(pxpelota, pypelota,
                           puntos[i][0], puntos[i][1]);
    double dist2= distancia(pxpelota+vxpelota/4.0, pypelota+vypelota/4.0,
                           puntos[i][0], puntos[i][1]);
    // Si la distancia es menor que distchoque, guardarla
    if (dist2<dist && dist<distchoque) {
      distchoque= dist;
      xladrillo= x;
      yladrillo= y;
      pxchoque= puntos[i][0];
      pychoque= puntos[i][1];
    }
  }
}

// Hacer las acciones correspondientes al choque de la
// bola con un ladrillo dado en (yladrillo,xladrillo)
void choqueladrillo ()
{
  // Ladrillo de color
  if (ladrillos[yladrillo][xladrillo]<=7)
    ladrillos[yladrillo][xladrillo]= 0;
  // Ladrillo gris
  else if (ladrillos[yladrillo][xladrillo]<=20)
    ladrillos[yladrillo][xladrillo]--;
  npuntos+= 10;
  // Calcular la nueva velocidad según el ángulo de choque
  double dist= distancia(pxchoque,pychoque,pxpelota,pypelota);
  double ex= (pxchoque-pxpelota)/dist;
  double ey= (pychoque-pypelota)/dist;
  double p1= -vxpelota*ex-vypelota*ey;
  double p2= vxpelota*ey-vypelota*ex;
  vxpelota= ex*p1+ey*p2;
  vypelota= ey*p1-ex*p2;
  // Ciudado si la velocidad vertical es próxima a 0
  if (vypelota>=0 && vypelota<0.1) vypelota= 0.1;
  else if (vypelota<=0 && vypelota>-0.1) vypelota= -0.1;
}

// Efectuar el movimiento de la bola
// teniendo en cuenta: estado inicial, paredes, techo, suelo,
// ladrillos y nave
void movimientobola()
{
  pxnave= mouseX;
  // Estado inicial: bola parada (velocidad 0)
  // La bola se moverá con el ratón y arranca cuando se pulse
  if (vxpelota==0.0 && vypelota==0.0) {
    pxpelota= mouseX+10;
    pypelota= 286;
    if (mousePressed) {
      vxpelota= 1+random(0.25);
      vypelota= -1+random(0.25);
    }
    return;
  }
  else {
    // Bola en movimiento: mover según su velocidad
    pxpelota= pxpelota+vxpelota;
    pypelota= pypelota+vypelota;
    // Choque con la pared derecha
    if (pxpelota+tambola/2>=310 && vxpelota>0) {
      vxpelota= -1*vxpelota;
      npuntos++;
    }
    // Choque con la pared izquierda
    if (pxpelota-tambola/2<=10 && vxpelota<0) {
      vxpelota= -1*vxpelota;
      npuntos++;
    }
    // La bola cae por el suelo
    if (pypelota+tambola/2>=320 && vypelota>-0.1) {
      vxpelota= 0.0;
      vypelota= 0.0;
      nvidas--;
    }
    // Choque con el techo
    if (pypelota-tambola/2<=10 && vypelota<0) {
      vypelota= -1*vypelota;
      npuntos++;
    }
    // Posible choque de la bola con la nave
    if (pypelota>=285 && pypelota<=295 && vypelota>=0) {
      // Choque con la bola: calcular el ángulo de rebote
      if (pxpelota>=pxnave-tamnave/2-3 && pxpelota<=pxnave+tamnave/2+3) {
        double nx= -sin((pxpelota-pxnave)/(tamnave));
        double ny= cos((pxpelota-pxnave)/(tamnave));
        double p1= -nx*vxpelota-ny*vypelota;
        double p2= ny*vxpelota-nx*vypelota;
        vxpelota= p1*nx+p2*ny;
        vypelota= -abs(p1*ny-p2*nx);
        if (vypelota>-0.1)
          vypelota= -0.1;
      }
    }
    // Posible choque con los ladrillos: comprobar ladrillos
    // cercanos y hacer el choque con el que corresponda
    if (pypelota>=priY-tambola/2 && pypelota<=priY+maxY*tamY+tambola/2) {
      int celdax= floor((pxpelota-10)/tamX);
      int celday= floor((pypelota-priY)/tamY);
      distchoque= tambola/2.0+0.001;
      for (int y= celday-1; y<=celday+1; y++)
        for (int x= celdax-1; x<=celdax+1; x++)
           compruebaladrillo(y, x);
      if (distchoque<tambola/2.0)
        choqueladrillo();
    }
  }
  pasos++;
  // Cada 150 pasos, se añade un poco de aleatoriedad a
  // la velocidad de la pelota y se le da velocidad (si no
  // supera un límite). Cuidado con que la velocidad
  // vertical no sea 0 o próxima a 0
  if (pasos>=150) {
    pasos= 0;
    if (abs(vypelota)>0.1)
      vypelota+= random(0.2)-0.1;
    if (abs(vypelota)<0.1)
      if (vypelota<=0) vypelota= -0.1;
      else vypelota= 0.1;
    vxpelota+= random(0.2)-0.1;
    // Aumentar velocidad
    if (abs(vxpelota)<4 && abs(vypelota)<4) {
      vxpelota= vxpelota*1.025;
      vypelota= vypelota*1.025;
    }
  }
}

// Función principal de la animación
void principal()
{
  // Juego termidado
  if (nvidas<=0) {
    pintaladrillos();
    pintabola();
    pintanave();
    pintagameover();
  }
  else {
    // Juego en marcha
    for (int n=0; n<4; n++)
       movimientobola();
    pintaladrillos();
    pintabola();
    pintanave();
    // Fase terminada: pasar a la nueva fase
    if (cuentalad==0) {
      nfase= nfase%sizeOf(fases)+1;
      nvidas++;
      inicializa(nfase);
    }
  }
}

// Programa principal
void main() {
  inicializa(nfase);
  animate(principal);
}
